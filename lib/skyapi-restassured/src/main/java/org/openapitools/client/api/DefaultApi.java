/*
 * Skycoin REST API.
 * Skycoin is a next-generation cryptocurrency.
 *
 * The version of the OpenAPI document: 0.27.0
 * Contact: contact@skycoin.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import com.google.gson.reflect.TypeToken;
import org.openapitools.client.model.Address;
import org.openapitools.client.model.BlockSchema;
import org.openapitools.client.model.InlineResponse200;
import org.openapitools.client.model.InlineResponse2001;
import org.openapitools.client.model.InlineResponse20010;
import org.openapitools.client.model.InlineResponse2002;
import org.openapitools.client.model.InlineResponse2003;
import org.openapitools.client.model.InlineResponse2004;
import org.openapitools.client.model.InlineResponse2005;
import org.openapitools.client.model.InlineResponse2006;
import org.openapitools.client.model.InlineResponse2007;
import org.openapitools.client.model.InlineResponse2008;
import org.openapitools.client.model.InlineResponse2009;
import org.openapitools.client.model.InlineResponseDefault;
import org.openapitools.client.model.NetworkConnectionSchema;
import org.openapitools.client.model.Transaction;
import org.openapitools.client.model.TransactionV2ParamsAddress;
import org.openapitools.client.model.TransactionV2ParamsUnspent;
import org.openapitools.client.model.TransactionVerifyRequest;
import org.openapitools.client.model.WalletTransactionRequest;
import org.openapitools.client.model.WalletTransactionSignRequest;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import io.restassured.RestAssured;
import io.restassured.builder.RequestSpecBuilder;
import io.restassured.builder.ResponseSpecBuilder;
import io.restassured.http.Method;
import io.restassured.response.Response;
import io.swagger.annotations.*;

import java.lang.reflect.Type;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import org.openapitools.client.JSON;

import static io.restassured.http.Method.*;

@Api(value = "Default")
public class DefaultApi {

    private RequestSpecBuilder reqSpec;

    private DefaultApi(RequestSpecBuilder reqSpec) {
        this.reqSpec = reqSpec;
    }

    public static DefaultApi _default(RequestSpecBuilder reqSpec) {
        return new DefaultApi(reqSpec);
    }


    @ApiOperation(value = "Returns the total number of unique address that have coins.",
            notes = "",
            nickname = "addressCount",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "addressCount response object") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public AddressCountOper addressCount() {
        return new AddressCountOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "Returns the historical, spent outputs associated with an address",
            nickname = "addressUxouts",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Return address uxouts") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public AddressUxoutsOper addressUxouts() {
        return new AddressUxoutsOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "",
            nickname = "apiV1RawtxGet",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Response is araw transaction by id")  })
    public ApiV1RawtxGetOper apiV1RawtxGet() {
        return new ApiV1RawtxGetOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "",
            nickname = "apiV2MetricsGet",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Metrics")  })
    public ApiV2MetricsGetOper apiV2MetricsGet() {
        return new ApiV2MetricsGetOper(reqSpec);
    }

    @ApiOperation(value = "Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.",
            notes = "",
            nickname = "balanceGet",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Returns the balance of one or more addresses") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public BalanceGetOper balanceGet() {
        return new BalanceGetOper(reqSpec);
    }

    @ApiOperation(value = "Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.",
            notes = "",
            nickname = "balancePost",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Returns the balance of one or more addresses") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public BalancePostOper balancePost() {
        return new BalancePostOper(reqSpec);
    }

    @ApiOperation(value = "Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.",
            notes = "",
            nickname = "block",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Return block Array") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public BlockOper block() {
        return new BlockOper(reqSpec);
    }

    @ApiOperation(value = "Returns the blockchain metadata.",
            notes = "",
            nickname = "blockchainMetadata",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint returns the blockchain metadata.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public BlockchainMetadataOper blockchainMetadata() {
        return new BlockchainMetadataOper(reqSpec);
    }

    @ApiOperation(value = "Returns the blockchain sync progress.",
            notes = "",
            nickname = "blockchainProgress",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint returns the blockchain sync progress") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public BlockchainProgressOper blockchainProgress() {
        return new BlockchainProgressOper(reqSpec);
    }

    @ApiOperation(value = "Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.",
            notes = "",
            nickname = "blocks",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Get blocks in specific range") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public BlocksOper blocks() {
        return new BlocksOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "coinSupplyHandler returns coin distribution supply stats",
            nickname = "coinSupply",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "CoinSupply records the coin supply info.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public CoinSupplyOper coinSupply() {
        return new CoinSupplyOper(reqSpec);
    }

    @ApiOperation(value = "Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.",
            notes = "",
            nickname = "csrf",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Return a csrf Token.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public CsrfOper csrf() {
        return new CsrfOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "",
            nickname = "dataDELETE",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint returns empty json") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public DataDELETEOper dataDELETE() {
        return new DataDELETEOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "",
            nickname = "dataGET",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Return multiKey") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public DataGETOper dataGET() {
        return new DataGETOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "",
            nickname = "dataPOST",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint returns empty json") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public DataPOSTOper dataPOST() {
        return new DataPOSTOper(reqSpec);
    }

    @ApiOperation(value = "defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.",
            notes = "",
            nickname = "defaultConnections",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint return an list of default connections.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public DefaultConnectionsOper defaultConnections() {
        return new DefaultConnectionsOper(reqSpec);
    }

    @ApiOperation(value = "Returns node health data.",
            notes = "",
            nickname = "health",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint returns node health data.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public HealthOper health() {
        return new HealthOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "Returns the most recent N blocks on the blockchain",
            nickname = "lastBlocks",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Returns the most recent N blocks on the blockchain") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public LastBlocksOper lastBlocks() {
        return new LastBlocksOper(reqSpec);
    }

    @ApiOperation(value = "This endpoint returns a specific connection.",
            notes = "",
            nickname = "networkConnection",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint return a connection struct") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public NetworkConnectionOper networkConnection() {
        return new NetworkConnectionOper(reqSpec);
    }

    @ApiOperation(value = "This endpoint returns all outgoings connections.",
            notes = "",
            nickname = "networkConnections",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint return networks connections") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public NetworkConnectionsOper networkConnections() {
        return new NetworkConnectionsOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "This endpoint disconnects a connection by ID or address",
            nickname = "networkConnectionsDisconnect",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public NetworkConnectionsDisconnectOper networkConnectionsDisconnect() {
        return new NetworkConnectionsDisconnectOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "This endpoint returns all connections found through peer exchange",
            nickname = "networkConnectionsExchange",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint return a list of all connections found through peer exchange.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public NetworkConnectionsExchangeOper networkConnectionsExchange() {
        return new NetworkConnectionsExchangeOper(reqSpec);
    }

    @ApiOperation(value = "trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.",
            notes = "",
            nickname = "networkConnectionsTrust",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint return a list of trusted connections.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public NetworkConnectionsTrustOper networkConnectionsTrust() {
        return new NetworkConnectionsTrustOper(reqSpec);
    }

    @ApiOperation(value = "If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.",
            notes = "",
            nickname = "outputsGet",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "UnspentOutputsSummary records unspent outputs in different status.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public OutputsGetOper outputsGet() {
        return new OutputsGetOper(reqSpec);
    }

    @ApiOperation(value = "If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.",
            notes = "",
            nickname = "outputsPost",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "UnspentOutputsSummary records unspent outputs in different status.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public OutputsPostOper outputsPost() {
        return new OutputsPostOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "",
            nickname = "pendingTxs",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Transaction inputs include the owner address, coins, hours and calculated hours.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public PendingTxsOper pendingTxs() {
        return new PendingTxsOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "Broadcasts all unconfirmed transactions from the unconfirmed transaction pool",
            nickname = "resendUnconfirmedTxns",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "OK, Broadcasts all unconfirmed transactions from the unconfirmed transaction pool") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public ResendUnconfirmedTxnsOper resendUnconfirmedTxns() {
        return new ResendUnconfirmedTxnsOper(reqSpec);
    }

    @ApiOperation(value = "Returns the top skycoin holders.",
            notes = "",
            nickname = "richlist",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Represent richlist response") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public RichlistOper richlist() {
        return new RichlistOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "Returns a transaction identified by its txid hash with just id",
            nickname = "transaction",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Returns a transaction identified by its txid hash.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public TransactionOper transaction() {
        return new TransactionOper(reqSpec);
    }

    @ApiOperation(value = "Broadcast a hex-encoded, serialized transaction to the network.",
            notes = "",
            nickname = "transactionInject",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Broadcasts a hex-encoded, serialized transaction to the network") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public TransactionInjectOper transactionInject() {
        return new TransactionInjectOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "",
            nickname = "transactionPost",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Response is a transaction") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public TransactionPostOper transactionPost() {
        return new TransactionPostOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "",
            nickname = "transactionPostUnspent",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Response is a transaction") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public TransactionPostUnspentOper transactionPostUnspent() {
        return new TransactionPostUnspentOper(reqSpec);
    }

    @ApiOperation(value = "Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.",
            notes = "",
            nickname = "transactionRaw",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Returns the hex-encoded byte serialization of a transaction") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public TransactionRawOper transactionRaw() {
        return new TransactionRawOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "Decode and verify an encoded transaction",
            nickname = "transactionVerify",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Responses ok") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public TransactionVerifyOper transactionVerify() {
        return new TransactionVerifyOper(reqSpec);
    }

    @ApiOperation(value = "Returns transactions that match the filters.",
            notes = "",
            nickname = "transactionsGet",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Returns transactions that match the filters.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public TransactionsGetOper transactionsGet() {
        return new TransactionsGetOper(reqSpec);
    }

    @ApiOperation(value = "Returns transactions that match the filters.",
            notes = "",
            nickname = "transactionsPost",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Returns transactions that match the filters.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public TransactionsPostOper transactionsPost() {
        return new TransactionsPostOper(reqSpec);
    }

    @ApiOperation(value = "Returns an unspent output by ID.",
            notes = "",
            nickname = "uxout",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Response for endpoint /api/v1/uxout") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public UxoutOper uxout() {
        return new UxoutOper(reqSpec);
    }

    @ApiOperation(value = "Verifies a Skycoin address.",
            notes = "",
            nickname = "verifyAddress",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public VerifyAddressOper verifyAddress() {
        return new VerifyAddressOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "versionHandler returns the application version info",
            nickname = "version",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "BuildInfo represents the build info") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public VersionOper version() {
        return new VersionOper(reqSpec);
    }

    @ApiOperation(value = "Returns a wallet by id.",
            notes = "",
            nickname = "wallet",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Response for endpoint /api/v1/wallet") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletOper wallet() {
        return new WalletOper(reqSpec);
    }

    @ApiOperation(value = "Returns the wallet's balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.",
            notes = "",
            nickname = "walletBalance",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Returns the wallets balance") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletBalanceOper walletBalance() {
        return new WalletBalanceOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "Create a wallet",
            nickname = "walletCreate",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Response for endpoint /api/v1/wallet") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletCreateOper walletCreate() {
        return new WalletCreateOper(reqSpec);
    }

    @ApiOperation(value = "Decrypts wallet.",
            notes = "",
            nickname = "walletDecrypt",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint decrypts wallets.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletDecryptOper walletDecrypt() {
        return new WalletDecryptOper(reqSpec);
    }

    @ApiOperation(value = "Encrypt wallet.",
            notes = "",
            nickname = "walletEncrypt",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint encrypt wallets.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletEncryptOper walletEncrypt() {
        return new WalletEncryptOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "Returns the wallet directory path",
            nickname = "walletFolder",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint return the wallet directory path") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletFolderOper walletFolder() {
        return new WalletFolderOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "Generates new addresses",
            nickname = "walletNewAddress",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint generate new addresses") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletNewAddressOper walletNewAddress() {
        return new WalletNewAddressOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "Returns the wallet directory path",
            nickname = "walletNewSeed",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Generates wallet seed") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletNewSeedOper walletNewSeed() {
        return new WalletNewSeedOper(reqSpec);
    }

    @ApiOperation(value = "Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.",
            notes = "Recovers an encrypted wallet by providing the wallet seed and optional seed passphrase",
            nickname = "walletRecover",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint recover wallets.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletRecoverOper walletRecover() {
        return new WalletRecoverOper(reqSpec);
    }

    @ApiOperation(value = "This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.",
            notes = "",
            nickname = "walletSeed",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint Returns seed of wallet of given id") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletSeedOper walletSeed() {
        return new WalletSeedOper(reqSpec);
    }

    @ApiOperation(value = "Verifies a wallet seed.",
            notes = "",
            nickname = "walletSeedVerify",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Verifies a wallet seed.") ,
            @ApiResponse(code = 422, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletSeedVerifyOper walletSeedVerify() {
        return new WalletSeedVerifyOper(reqSpec);
    }

    @ApiOperation(value = "Creates a signed transaction",
            notes = "",
            nickname = "walletTransaction",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Returns blocks between a start and end point.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletTransactionOper walletTransaction() {
        return new WalletTransactionOper(reqSpec);
    }

    @ApiOperation(value = "Creates a signed transaction",
            notes = "",
            nickname = "walletTransactionSign",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "Signs an unsigned transaction, returning the transaction with updated signatures and the encoded, serialized transaction.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletTransactionSignOper walletTransactionSign() {
        return new WalletTransactionSignOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "",
            nickname = "walletTransactions",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint returns all unconfirmed transactions for all addresses in a given wallet.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletTransactionsOper walletTransactions() {
        return new WalletTransactionsOper(reqSpec);
    }

    @ApiOperation(value = "Unloads wallet from the wallet service.",
            notes = "",
            nickname = "walletUnload",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint returns nothing.") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletUnloadOper walletUnload() {
        return new WalletUnloadOper(reqSpec);
    }

    @ApiOperation(value = "Update the wallet.",
            notes = "",
            nickname = "walletUpdate",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint Returns the label the wallet will be updated to .") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletUpdateOper walletUpdate() {
        return new WalletUpdateOper(reqSpec);
    }

    @ApiOperation(value = "",
            notes = "Returns all loaded wallets",
            nickname = "wallets",
            tags = { "default" })
    @ApiResponses(value = { 
            @ApiResponse(code = 200, message = "This endpoint return all loaded wallets") ,
            @ApiResponse(code = 0, message = "A GenericError is the default error message that is generated. For certain status codes there are more appropriate error structures.")  })
    public WalletsOper wallets() {
        return new WalletsOper(reqSpec);
    }

    /**
     * Customise request specification
     * @param consumer consumer
     * @return api
     */
    public DefaultApi reqSpec(Consumer<RequestSpecBuilder> consumer) {
        consumer.accept(reqSpec);
        return this;
    }

    /**
     * Returns the total number of unique address that have coins.
     * 
     *
     * return InlineResponse200
     */
    public static class AddressCountOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/addresscount";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public AddressCountOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/addresscount
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/addresscount
         * @param handler handler
         * @return InlineResponse200
         */
        public InlineResponse200 executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<InlineResponse200>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public AddressCountOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public AddressCountOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * Returns the historical, spent outputs associated with an address
     *
     * @see #addressQuery address to filter by (required)
     * return List&lt;Object&gt;
     */
    public static class AddressUxoutsOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/address_uxouts";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public AddressUxoutsOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/address_uxouts
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/address_uxouts
         * @param handler handler
         * @return List&lt;Object&gt;
         */
        public List<Object> executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<List<Object>>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ADDRESS_QUERY = "address";

        /**
         * @param address (String) address to filter by (required)
         * @return operation
         */
        public AddressUxoutsOper addressQuery(Object... address) {
            reqSpec.addQueryParam(ADDRESS_QUERY, address);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public AddressUxoutsOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public AddressUxoutsOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * 
     *
     * return String
     */
    public static class ApiV1RawtxGetOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/rawtx";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public ApiV1RawtxGetOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("text/plain");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/rawtx
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/rawtx
         * @param handler handler
         * @return String
         */
        public String executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<String>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public ApiV1RawtxGetOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public ApiV1RawtxGetOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * 
     *
     * return String
     */
    public static class ApiV2MetricsGetOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v2/metrics";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public ApiV2MetricsGetOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("text/plain");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v2/metrics
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v2/metrics
         * @param handler handler
         * @return String
         */
        public String executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<String>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public ApiV2MetricsGetOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public ApiV2MetricsGetOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * 
     *
     * @see #addrsQuery command separated list of addresses (required)
     * return Object
     */
    public static class BalanceGetOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/balance";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public BalanceGetOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/balance
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/balance
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ADDRS_QUERY = "addrs";

        /**
         * @param addrs (String) command separated list of addresses (required)
         * @return operation
         */
        public BalanceGetOper addrsQuery(Object... addrs) {
            reqSpec.addQueryParam(ADDRS_QUERY, addrs);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public BalanceGetOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public BalanceGetOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * 
     *
     * @see #addrsQuery command separated list of addresses (required)
     * return Object
     */
    public static class BalancePostOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/balance";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public BalancePostOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/balance
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/balance
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ADDRS_QUERY = "addrs";

        /**
         * @param addrs (String) command separated list of addresses (required)
         * @return operation
         */
        public BalancePostOper addrsQuery(Object... addrs) {
            reqSpec.addQueryParam(ADDRS_QUERY, addrs);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public BalancePostOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public BalancePostOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * 
     *
     * @see #hashQuery get block by hash (optional)
     * @see #seqQuery get block by sequence number (optional)
     * return List&lt;BlockSchema&gt;
     */
    public static class BlockOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/block";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public BlockOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/block
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/block
         * @param handler handler
         * @return List&lt;BlockSchema&gt;
         */
        public List<BlockSchema> executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<List<BlockSchema>>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String HASH_QUERY = "hash";

        /**
         * @param hash (String) get block by hash (optional)
         * @return operation
         */
        public BlockOper hashQuery(Object... hash) {
            reqSpec.addQueryParam(HASH_QUERY, hash);
            return this;
        }

        public static final String SEQ_QUERY = "seq";

        /**
         * @param seq (Integer) get block by sequence number (optional)
         * @return operation
         */
        public BlockOper seqQuery(Object... seq) {
            reqSpec.addQueryParam(SEQ_QUERY, seq);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public BlockOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public BlockOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns the blockchain metadata.
     * 
     *
     * return Object
     */
    public static class BlockchainMetadataOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/blockchain/metadata";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public BlockchainMetadataOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/blockchain/metadata
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/blockchain/metadata
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public BlockchainMetadataOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public BlockchainMetadataOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns the blockchain sync progress.
     * 
     *
     * return Object
     */
    public static class BlockchainProgressOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/blockchain/progress";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public BlockchainProgressOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/blockchain/progress
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/blockchain/progress
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public BlockchainProgressOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public BlockchainProgressOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns the balance of one or more addresses, both confirmed and predicted. The predicted balance is the confirmed balance minus the pending spends.
     * 
     *
     * @see #startQuery start seq (optional)
     * @see #endQuery end seq (optional)
     * @see #seqQuery comma-separated list of block seqs (optional, default to new ArrayList&lt;Integer&gt;())
     * return InlineResponse2001
     */
    public static class BlocksOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/blocks";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public BlocksOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/blocks
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/blocks
         * @param handler handler
         * @return InlineResponse2001
         */
        public InlineResponse2001 executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<InlineResponse2001>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String START_QUERY = "start";

        /**
         * @param start (Integer) start seq (optional)
         * @return operation
         */
        public BlocksOper startQuery(Object... start) {
            reqSpec.addQueryParam(START_QUERY, start);
            return this;
        }

        public static final String END_QUERY = "end";

        /**
         * @param end (Integer) end seq (optional)
         * @return operation
         */
        public BlocksOper endQuery(Object... end) {
            reqSpec.addQueryParam(END_QUERY, end);
            return this;
        }

        public static final String SEQ_QUERY = "seq";

        /**
         * @param seq (List&lt;Integer&gt;) comma-separated list of block seqs (optional, default to new ArrayList&lt;Integer&gt;())
         * @return operation
         */
        public BlocksOper seqQuery(Object... seq) {
            reqSpec.addQueryParam(SEQ_QUERY, seq);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public BlocksOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public BlocksOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * coinSupplyHandler returns coin distribution supply stats
     *
     * return InlineResponse2002
     */
    public static class CoinSupplyOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/coinSupply";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public CoinSupplyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/coinSupply
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/coinSupply
         * @param handler handler
         * @return InlineResponse2002
         */
        public InlineResponse2002 executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<InlineResponse2002>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public CoinSupplyOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public CoinSupplyOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Creates a new CSRF token. Previous CSRF tokens are invalidated by this call.
     * 
     *
     * return InlineResponse2003
     */
    public static class CsrfOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/csrf";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public CsrfOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/csrf
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/csrf
         * @param handler handler
         * @return InlineResponse2003
         */
        public InlineResponse2003 executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<InlineResponse2003>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public CsrfOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public CsrfOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * 
     *
     * @see #typeHeader storage type. (optional)
     * @see #keyHeader key of the specific value to get. (optional)
     */
    public static class DataDELETEOper {

        public static final Method REQ_METHOD = DELETE;
        public static final String REQ_URI = "/api/v2/data";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public DataDELETEOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * DELETE /api/v2/data
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        public static final String TYPE_HEADER = "type";

        /**
         * @param type (String) storage type. (optional)
         * @return operation
         */
        public DataDELETEOper typeHeader(String type) {
            reqSpec.addHeader(TYPE_HEADER, type);
            return this;
        }

        public static final String KEY_HEADER = "key";

        /**
         * @param key (String) key of the specific value to get. (optional)
         * @return operation
         */
        public DataDELETEOper keyHeader(String key) {
            reqSpec.addHeader(KEY_HEADER, key);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public DataDELETEOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public DataDELETEOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * 
     *
     * @see #typeHeader storage type. (optional)
     * @see #keyHeader key of the specific value to get. (optional)
     * return Object
     */
    public static class DataGETOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v2/data";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public DataGETOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v2/data
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v2/data
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String TYPE_HEADER = "type";

        /**
         * @param type (String) storage type. (optional)
         * @return operation
         */
        public DataGETOper typeHeader(String type) {
            reqSpec.addHeader(TYPE_HEADER, type);
            return this;
        }

        public static final String KEY_HEADER = "key";

        /**
         * @param key (String) key of the specific value to get. (optional)
         * @return operation
         */
        public DataGETOper keyHeader(String key) {
            reqSpec.addHeader(KEY_HEADER, key);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public DataGETOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public DataGETOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * 
     *
     * @see #typeHeader storage type. (optional)
     * @see #keyHeader key of the specific value to get. (optional)
     * @see #valHeader additional value. (optional)
     */
    public static class DataPOSTOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v2/data";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public DataPOSTOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v2/data
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        public static final String TYPE_HEADER = "type";

        /**
         * @param type (String) storage type. (optional)
         * @return operation
         */
        public DataPOSTOper typeHeader(String type) {
            reqSpec.addHeader(TYPE_HEADER, type);
            return this;
        }

        public static final String KEY_HEADER = "key";

        /**
         * @param key (String) key of the specific value to get. (optional)
         * @return operation
         */
        public DataPOSTOper keyHeader(String key) {
            reqSpec.addHeader(KEY_HEADER, key);
            return this;
        }

        public static final String VAL_HEADER = "val";

        /**
         * @param val (String) additional value. (optional)
         * @return operation
         */
        public DataPOSTOper valHeader(String val) {
            reqSpec.addHeader(VAL_HEADER, val);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public DataPOSTOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public DataPOSTOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * defaultConnectionsHandler returns the list of default hardcoded bootstrap addresses.\\n They are not necessarily connected to.
     * 
     *
     * return List&lt;String&gt;
     */
    public static class DefaultConnectionsOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/network/defaultConnections";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public DefaultConnectionsOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/network/defaultConnections
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/network/defaultConnections
         * @param handler handler
         * @return List&lt;String&gt;
         */
        public List<String> executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<List<String>>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public DefaultConnectionsOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public DefaultConnectionsOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns node health data.
     * 
     *
     * return Object
     */
    public static class HealthOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/health";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public HealthOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/health
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/health
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public HealthOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public HealthOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * Returns the most recent N blocks on the blockchain
     *
     * @see #numQuery Num of blockss (required)
     * return Object
     */
    public static class LastBlocksOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/last_blocks";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public LastBlocksOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/last_blocks
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/last_blocks
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String NUM_QUERY = "num";

        /**
         * @param num (Integer) Num of blockss (required)
         * @return operation
         */
        public LastBlocksOper numQuery(Object... num) {
            reqSpec.addQueryParam(NUM_QUERY, num);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public LastBlocksOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public LastBlocksOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * This endpoint returns a specific connection.
     * 
     *
     * @see #addrQuery Address port (required)
     * return NetworkConnectionSchema
     */
    public static class NetworkConnectionOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/network/connection";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public NetworkConnectionOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/network/connection
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/network/connection
         * @param handler handler
         * @return NetworkConnectionSchema
         */
        public NetworkConnectionSchema executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<NetworkConnectionSchema>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ADDR_QUERY = "addr";

        /**
         * @param addr (String) Address port (required)
         * @return operation
         */
        public NetworkConnectionOper addrQuery(Object... addr) {
            reqSpec.addQueryParam(ADDR_QUERY, addr);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public NetworkConnectionOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public NetworkConnectionOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * This endpoint returns all outgoings connections.
     * 
     *
     * @see #statesQuery Connection status. (optional)
     * @see #directionQuery Direction of the connection. (optional)
     * return InlineResponse2004
     */
    public static class NetworkConnectionsOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/network/connections";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public NetworkConnectionsOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/network/connections
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/network/connections
         * @param handler handler
         * @return InlineResponse2004
         */
        public InlineResponse2004 executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<InlineResponse2004>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String STATES_QUERY = "states";

        /**
         * @param states (String) Connection status. (optional)
         * @return operation
         */
        public NetworkConnectionsOper statesQuery(Object... states) {
            reqSpec.addQueryParam(STATES_QUERY, states);
            return this;
        }

        public static final String DIRECTION_QUERY = "direction";

        /**
         * @param direction (String) Direction of the connection. (optional)
         * @return operation
         */
        public NetworkConnectionsOper directionQuery(Object... direction) {
            reqSpec.addQueryParam(DIRECTION_QUERY, direction);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public NetworkConnectionsOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public NetworkConnectionsOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * This endpoint disconnects a connection by ID or address
     *
     * @see #idQuery Address id. (required)
     */
    public static class NetworkConnectionsDisconnectOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/network/connection/disconnect";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public NetworkConnectionsDisconnectOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/network/connection/disconnect
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        public static final String ID_QUERY = "id";

        /**
         * @param id (String) Address id. (required)
         * @return operation
         */
        public NetworkConnectionsDisconnectOper idQuery(Object... id) {
            reqSpec.addQueryParam(ID_QUERY, id);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public NetworkConnectionsDisconnectOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public NetworkConnectionsDisconnectOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * This endpoint returns all connections found through peer exchange
     *
     * return List&lt;String&gt;
     */
    public static class NetworkConnectionsExchangeOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/network/connections/exchange";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public NetworkConnectionsExchangeOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/network/connections/exchange
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/network/connections/exchange
         * @param handler handler
         * @return List&lt;String&gt;
         */
        public List<String> executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<List<String>>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public NetworkConnectionsExchangeOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public NetworkConnectionsExchangeOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * trustConnectionsHandler returns all trusted connections.\\n They are not necessarily connected to. In the default configuration, these will be a subset of the default hardcoded bootstrap addresses.
     * 
     *
     * return List&lt;String&gt;
     */
    public static class NetworkConnectionsTrustOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/network/connections/trust";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public NetworkConnectionsTrustOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/network/connections/trust
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/network/connections/trust
         * @param handler handler
         * @return List&lt;String&gt;
         */
        public List<String> executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<List<String>>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public NetworkConnectionsTrustOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public NetworkConnectionsTrustOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * 
     *
     * @see #addressQuery  (optional, default to new ArrayList&lt;String&gt;())
     * @see #hashQuery  (optional, default to new ArrayList&lt;String&gt;())
     * return Object
     */
    public static class OutputsGetOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/outputs";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public OutputsGetOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/outputs
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/outputs
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ADDRESS_QUERY = "address";

        /**
         * @param address (List&lt;String&gt;)  (optional, default to new ArrayList&lt;String&gt;())
         * @return operation
         */
        public OutputsGetOper addressQuery(Object... address) {
            reqSpec.addQueryParam(ADDRESS_QUERY, address);
            return this;
        }

        public static final String HASH_QUERY = "hash";

        /**
         * @param hash (List&lt;String&gt;)  (optional, default to new ArrayList&lt;String&gt;())
         * @return operation
         */
        public OutputsGetOper hashQuery(Object... hash) {
            reqSpec.addQueryParam(HASH_QUERY, hash);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public OutputsGetOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public OutputsGetOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * If neither addrs nor hashes are specificed, return all unspent outputs. If only one filter is specified, then return outputs match the filter. Both filters cannot be specified.
     * 
     *
     * @see #addressQuery  (optional)
     * @see #hashQuery  (optional)
     * return Object
     */
    public static class OutputsPostOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/outputs";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public OutputsPostOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/outputs
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/outputs
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ADDRESS_QUERY = "address";

        /**
         * @param address (String)  (optional)
         * @return operation
         */
        public OutputsPostOper addressQuery(Object... address) {
            reqSpec.addQueryParam(ADDRESS_QUERY, address);
            return this;
        }

        public static final String HASH_QUERY = "hash";

        /**
         * @param hash (String)  (optional)
         * @return operation
         */
        public OutputsPostOper hashQuery(Object... hash) {
            reqSpec.addQueryParam(HASH_QUERY, hash);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public OutputsPostOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public OutputsPostOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * 
     *
     * return List&lt;InlineResponse20010&gt;
     */
    public static class PendingTxsOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/pendingTxs";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public PendingTxsOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/pendingTxs
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/pendingTxs
         * @param handler handler
         * @return List&lt;InlineResponse20010&gt;
         */
        public List<InlineResponse20010> executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<List<InlineResponse20010>>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public PendingTxsOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public PendingTxsOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * Broadcasts all unconfirmed transactions from the unconfirmed transaction pool
     *
     * return Object
     */
    public static class ResendUnconfirmedTxnsOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/resendUnconfirmedTxns";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public ResendUnconfirmedTxnsOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/resendUnconfirmedTxns
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/resendUnconfirmedTxns
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public ResendUnconfirmedTxnsOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public ResendUnconfirmedTxnsOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns the top skycoin holders.
     * 
     *
     * @see #includeDistributionQuery include distribution addresses or not, default value false (optional)
     * @see #nQuery include distribution addresses or not, default value false (optional)
     * return Object
     */
    public static class RichlistOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/richlist";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public RichlistOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/richlist
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/richlist
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String INCLUDE_DISTRIBUTION_QUERY = "include-distribution";

        /**
         * @param includeDistribution (Boolean) include distribution addresses or not, default value false (optional)
         * @return operation
         */
        public RichlistOper includeDistributionQuery(Object... includeDistribution) {
            reqSpec.addQueryParam(INCLUDE_DISTRIBUTION_QUERY, includeDistribution);
            return this;
        }

        public static final String N_QUERY = "n";

        /**
         * @param n (String) include distribution addresses or not, default value false (optional)
         * @return operation
         */
        public RichlistOper nQuery(Object... n) {
            reqSpec.addQueryParam(N_QUERY, n);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public RichlistOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public RichlistOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * Returns a transaction identified by its txid hash with just id
     *
     * @see #txidQuery transaction Id (required)
     * return Transaction
     */
    public static class TransactionOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/transaction";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public TransactionOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/transaction
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/transaction
         * @param handler handler
         * @return Transaction
         */
        public Transaction executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Transaction>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String TXID_QUERY = "txid";

        /**
         * @param txid (String) transaction Id (required)
         * @return operation
         */
        public TransactionOper txidQuery(Object... txid) {
            reqSpec.addQueryParam(TXID_QUERY, txid);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Broadcast a hex-encoded, serialized transaction to the network.
     * 
     *
     * @see #rawtxHeader hex-encoded serialized transaction string. (required)
     * @see #noBroadcastHeader Disable the network broadcast (optional)
     * return String
     */
    public static class TransactionInjectOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/injectTransaction";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public TransactionInjectOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/injectTransaction
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/injectTransaction
         * @param handler handler
         * @return String
         */
        public String executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<String>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String RAWTX_HEADER = "rawtx";

        /**
         * @param rawtx (String) hex-encoded serialized transaction string. (required)
         * @return operation
         */
        public TransactionInjectOper rawtxHeader(String rawtx) {
            reqSpec.addHeader(RAWTX_HEADER, rawtx);
            return this;
        }

        public static final String NO_BROADCAST_HEADER = "no_broadcast";

        /**
         * @param noBroadcast (Boolean) Disable the network broadcast (optional)
         * @return operation
         */
        public TransactionInjectOper noBroadcastHeader(String noBroadcast) {
            reqSpec.addHeader(NO_BROADCAST_HEADER, noBroadcast);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionInjectOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionInjectOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * 
     *
     * @see #body  (optional)
     * return InlineResponse2008
     */
    public static class TransactionPostOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v2/transaction";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public TransactionPostOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType("application/json");
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v2/transaction
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v2/transaction
         * @param handler handler
         * @return InlineResponse2008
         */
        public InlineResponse2008 executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<InlineResponse2008>(){}.getType();
            return execute(handler).as(type);
        }

         /**
         * @param transactionV2ParamsAddress (TransactionV2ParamsAddress)  (optional)
         * @return operation
         */
        public TransactionPostOper body(TransactionV2ParamsAddress transactionV2ParamsAddress) {
            reqSpec.setBody(transactionV2ParamsAddress);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionPostOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionPostOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * 
     *
     * @see #body Unspent parameters (required)
     * return InlineResponse2008
     */
    public static class TransactionPostUnspentOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v2/transaction/unspent";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public TransactionPostUnspentOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType("application/json");
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v2/transaction/unspent
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v2/transaction/unspent
         * @param handler handler
         * @return InlineResponse2008
         */
        public InlineResponse2008 executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<InlineResponse2008>(){}.getType();
            return execute(handler).as(type);
        }

         /**
         * @param transactionV2ParamsUnspent (TransactionV2ParamsUnspent) Unspent parameters (required)
         * @return operation
         */
        public TransactionPostUnspentOper body(TransactionV2ParamsUnspent transactionV2ParamsUnspent) {
            reqSpec.setBody(transactionV2ParamsUnspent);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionPostUnspentOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionPostUnspentOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns the hex-encoded byte serialization of a transaction. The transaction may be confirmed or unconfirmed.
     * 
     *
     * @see #txidQuery Transaction id hash (optional)
     * return Object
     */
    public static class TransactionRawOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v2/transaction/raw";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public TransactionRawOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v2/transaction/raw
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v2/transaction/raw
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String TXID_QUERY = "txid";

        /**
         * @param txid (String) Transaction id hash (optional)
         * @return operation
         */
        public TransactionRawOper txidQuery(Object... txid) {
            reqSpec.addQueryParam(TXID_QUERY, txid);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionRawOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionRawOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * Decode and verify an encoded transaction
     *
     * @see #body  (required)
     * return Object
     */
    public static class TransactionVerifyOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v2/transaction/verify";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public TransactionVerifyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType("application/json");
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v2/transaction/verify
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v2/transaction/verify
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

         /**
         * @param transactionVerifyRequest (TransactionVerifyRequest)  (required)
         * @return operation
         */
        public TransactionVerifyOper body(TransactionVerifyRequest transactionVerifyRequest) {
            reqSpec.setBody(transactionVerifyRequest);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionVerifyOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionVerifyOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns transactions that match the filters.
     * 
     *
     * @see #addrsQuery command separated list of addresses (optional)
     * @see #confirmedQuery Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all] (optional)
     * return Object
     */
    public static class TransactionsGetOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/transactions";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public TransactionsGetOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/transactions
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/transactions
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ADDRS_QUERY = "addrs";

        /**
         * @param addrs (String) command separated list of addresses (optional)
         * @return operation
         */
        public TransactionsGetOper addrsQuery(Object... addrs) {
            reqSpec.addQueryParam(ADDRS_QUERY, addrs);
            return this;
        }

        public static final String CONFIRMED_QUERY = "confirmed";

        /**
         * @param confirmed (String) Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all] (optional)
         * @return operation
         */
        public TransactionsGetOper confirmedQuery(Object... confirmed) {
            reqSpec.addQueryParam(CONFIRMED_QUERY, confirmed);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionsGetOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionsGetOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns transactions that match the filters.
     * 
     *
     * @see #addrsQuery command separated list of addresses (optional)
     * @see #confirmedQuery Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all] (optional)
     * return Object
     */
    public static class TransactionsPostOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/transactions";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public TransactionsPostOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/transactions
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/transactions
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ADDRS_QUERY = "addrs";

        /**
         * @param addrs (String) command separated list of addresses (optional)
         * @return operation
         */
        public TransactionsPostOper addrsQuery(Object... addrs) {
            reqSpec.addQueryParam(ADDRS_QUERY, addrs);
            return this;
        }

        public static final String CONFIRMED_QUERY = "confirmed";

        /**
         * @param confirmed (String) Whether the transactions should be confirmed [optional, must be 0 or 1; if not provided, returns all] (optional)
         * @return operation
         */
        public TransactionsPostOper confirmedQuery(Object... confirmed) {
            reqSpec.addQueryParam(CONFIRMED_QUERY, confirmed);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionsPostOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public TransactionsPostOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns an unspent output by ID.
     * 
     *
     * @see #uxidQuery uxid to filter by (optional)
     * return Object
     */
    public static class UxoutOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/uxout";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public UxoutOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/uxout
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/uxout
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String UXID_QUERY = "uxid";

        /**
         * @param uxid (String) uxid to filter by (optional)
         * @return operation
         */
        public UxoutOper uxidQuery(Object... uxid) {
            reqSpec.addQueryParam(UXID_QUERY, uxid);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public UxoutOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public UxoutOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Verifies a Skycoin address.
     * 
     *
     * @see #addressQuery Address id. (required)
     * return Object
     */
    public static class VerifyAddressOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v2/address/verify";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public VerifyAddressOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v2/address/verify
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v2/address/verify
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ADDRESS_QUERY = "address";

        /**
         * @param address (Address) Address id. (required)
         * @return operation
         */
        public VerifyAddressOper addressQuery(Object... address) {
            reqSpec.addQueryParam(ADDRESS_QUERY, address);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public VerifyAddressOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public VerifyAddressOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * versionHandler returns the application version info
     *
     * return InlineResponse2005
     */
    public static class VersionOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/version";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public VersionOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/version
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/version
         * @param handler handler
         * @return InlineResponse2005
         */
        public InlineResponse2005 executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<InlineResponse2005>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public VersionOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public VersionOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns a wallet by id.
     * 
     *
     * @see #idQuery tags to filter by (required)
     * return Object
     */
    public static class WalletOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/wallet";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/wallet
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/wallet
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ID_QUERY = "id";

        /**
         * @param id (String) tags to filter by (required)
         * @return operation
         */
        public WalletOper idQuery(Object... id) {
            reqSpec.addQueryParam(ID_QUERY, id);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Returns the wallet&#39;s balance, both confirmed and predicted.  The predicted balance is the confirmed balance minus the pending spends.
     * 
     *
     * @see #idQuery tags to filter by (required)
     * return Object
     */
    public static class WalletBalanceOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/wallet/balance";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletBalanceOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/wallet/balance
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/wallet/balance
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ID_QUERY = "id";

        /**
         * @param id (String) tags to filter by (required)
         * @return operation
         */
        public WalletBalanceOper idQuery(Object... id) {
            reqSpec.addQueryParam(ID_QUERY, id);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletBalanceOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletBalanceOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * Create a wallet
     *
     * @see #typeHeader wallet seed passphrase [optional, bip44 type wallet only] (required)
     * @see #seedHeader Wallet seed. (required)
     * @see #labelHeader Wallet label. (required)
     * @see #seedPassphraseHeader wallet seed passphrase [optional, bip44 type wallet only] (optional)
     * @see #bip44CoinHeader BIP44 coin type [optional, defaults to 8000 (skycoin&#39;s coin type), only valid if type is \&quot;bip44\&quot;] (optional)
     * @see #xpubHeader xpub key [required for xpub wallets] (optional)
     * @see #scanHeader The number of addresses to scan ahead for balances. (optional)
     * @see #encryptHeader Encrypt wallet. (optional)
     * @see #passwordHeader Wallet Password (optional)
     * return Object
     */
    public static class WalletCreateOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/wallet/create";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletCreateOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/wallet/create
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/wallet/create
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String SEED_PASSPHRASE_HEADER = "seed-passphrase";

        /**
         * @param seedPassphrase (String) wallet seed passphrase [optional, bip44 type wallet only] (optional)
         * @return operation
         */
        public WalletCreateOper seedPassphraseHeader(String seedPassphrase) {
            reqSpec.addHeader(SEED_PASSPHRASE_HEADER, seedPassphrase);
            return this;
        }

        public static final String TYPE_HEADER = "type";

        /**
         * @param type (String) wallet seed passphrase [optional, bip44 type wallet only] (required)
         * @return operation
         */
        public WalletCreateOper typeHeader(String type) {
            reqSpec.addHeader(TYPE_HEADER, type);
            return this;
        }

        public static final String BIP44_COIN_HEADER = "bip44-coin";

        /**
         * @param bip44Coin (String) BIP44 coin type [optional, defaults to 8000 (skycoin&#39;s coin type), only valid if type is \&quot;bip44\&quot;] (optional)
         * @return operation
         */
        public WalletCreateOper bip44CoinHeader(String bip44Coin) {
            reqSpec.addHeader(BIP44_COIN_HEADER, bip44Coin);
            return this;
        }

        public static final String SEED_HEADER = "seed";

        /**
         * @param seed (String) Wallet seed. (required)
         * @return operation
         */
        public WalletCreateOper seedHeader(String seed) {
            reqSpec.addHeader(SEED_HEADER, seed);
            return this;
        }

        public static final String XPUB_HEADER = "xpub";

        /**
         * @param xpub (String) xpub key [required for xpub wallets] (optional)
         * @return operation
         */
        public WalletCreateOper xpubHeader(String xpub) {
            reqSpec.addHeader(XPUB_HEADER, xpub);
            return this;
        }

        public static final String LABEL_HEADER = "label";

        /**
         * @param label (String) Wallet label. (required)
         * @return operation
         */
        public WalletCreateOper labelHeader(String label) {
            reqSpec.addHeader(LABEL_HEADER, label);
            return this;
        }

        public static final String SCAN_HEADER = "scan";

        /**
         * @param scan (Integer) The number of addresses to scan ahead for balances. (optional)
         * @return operation
         */
        public WalletCreateOper scanHeader(String scan) {
            reqSpec.addHeader(SCAN_HEADER, scan);
            return this;
        }

        public static final String ENCRYPT_HEADER = "encrypt";

        /**
         * @param encrypt (Boolean) Encrypt wallet. (optional)
         * @return operation
         */
        public WalletCreateOper encryptHeader(String encrypt) {
            reqSpec.addHeader(ENCRYPT_HEADER, encrypt);
            return this;
        }

        public static final String PASSWORD_HEADER = "password";

        /**
         * @param password (String) Wallet Password (optional)
         * @return operation
         */
        public WalletCreateOper passwordHeader(String password) {
            reqSpec.addHeader(PASSWORD_HEADER, password);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletCreateOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletCreateOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Decrypts wallet.
     * 
     *
     * @see #idHeader Wallet id. (required)
     * @see #passwordHeader Wallet password. (required)
     * return Object
     */
    public static class WalletDecryptOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/wallet/decrypt";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletDecryptOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/wallet/decrypt
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/wallet/decrypt
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ID_HEADER = "id";

        /**
         * @param id (String) Wallet id. (required)
         * @return operation
         */
        public WalletDecryptOper idHeader(String id) {
            reqSpec.addHeader(ID_HEADER, id);
            return this;
        }

        public static final String PASSWORD_HEADER = "password";

        /**
         * @param password (String) Wallet password. (required)
         * @return operation
         */
        public WalletDecryptOper passwordHeader(String password) {
            reqSpec.addHeader(PASSWORD_HEADER, password);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletDecryptOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletDecryptOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Encrypt wallet.
     * 
     *
     * @see #idHeader Wallet id. (required)
     * @see #passwordHeader Wallet password. (required)
     * return Object
     */
    public static class WalletEncryptOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/wallet/encrypt";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletEncryptOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/wallet/encrypt
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/wallet/encrypt
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ID_HEADER = "id";

        /**
         * @param id (String) Wallet id. (required)
         * @return operation
         */
        public WalletEncryptOper idHeader(String id) {
            reqSpec.addHeader(ID_HEADER, id);
            return this;
        }

        public static final String PASSWORD_HEADER = "password";

        /**
         * @param password (String) Wallet password. (required)
         * @return operation
         */
        public WalletEncryptOper passwordHeader(String password) {
            reqSpec.addHeader(PASSWORD_HEADER, password);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletEncryptOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletEncryptOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * Returns the wallet directory path
     *
     * @see #addrQuery Address port (required)
     * return InlineResponse2007
     */
    public static class WalletFolderOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/wallets/folderName";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletFolderOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/wallets/folderName
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/wallets/folderName
         * @param handler handler
         * @return InlineResponse2007
         */
        public InlineResponse2007 executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<InlineResponse2007>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ADDR_QUERY = "addr";

        /**
         * @param addr (String) Address port (required)
         * @return operation
         */
        public WalletFolderOper addrQuery(Object... addr) {
            reqSpec.addQueryParam(ADDR_QUERY, addr);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletFolderOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletFolderOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * Generates new addresses
     *
     * @see #idQuery Wallet Id (required)
     * @see #numQuery The number you want to generate (optional)
     * @see #passwordQuery Wallet Password (optional)
     * return Object
     */
    public static class WalletNewAddressOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/wallet/newAddress";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletNewAddressOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/wallet/newAddress
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/wallet/newAddress
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ID_QUERY = "id";

        /**
         * @param id (String) Wallet Id (required)
         * @return operation
         */
        public WalletNewAddressOper idQuery(Object... id) {
            reqSpec.addQueryParam(ID_QUERY, id);
            return this;
        }

        public static final String NUM_QUERY = "num";

        /**
         * @param num (String) The number you want to generate (optional)
         * @return operation
         */
        public WalletNewAddressOper numQuery(Object... num) {
            reqSpec.addQueryParam(NUM_QUERY, num);
            return this;
        }

        public static final String PASSWORD_QUERY = "password";

        /**
         * @param password (String) Wallet Password (optional)
         * @return operation
         */
        public WalletNewAddressOper passwordQuery(Object... password) {
            reqSpec.addQueryParam(PASSWORD_QUERY, password);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletNewAddressOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletNewAddressOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * Returns the wallet directory path
     *
     * @see #entropyQuery Entropy bitSize. (optional)
     * return Object
     */
    public static class WalletNewSeedOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/wallet/newSeed";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletNewSeedOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/wallet/newSeed
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/wallet/newSeed
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ENTROPY_QUERY = "entropy";

        /**
         * @param entropy (String) Entropy bitSize. (optional)
         * @return operation
         */
        public WalletNewSeedOper entropyQuery(Object... entropy) {
            reqSpec.addQueryParam(ENTROPY_QUERY, entropy);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletNewSeedOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletNewSeedOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Recovers an encrypted wallet by providing the seed. The first address will be generated from seed and compared to the first address of the specified wallet. If they match, the wallet will be regenerated with an optional password. If the wallet is not encrypted, an error is returned.
     * Recovers an encrypted wallet by providing the wallet seed and optional seed passphrase
     *
     * @see #idHeader Wallet id. (required)
     * @see #seedHeader Wallet seed. (required)
     * @see #seedPassphraseHeader Wallet seed-passphrase. (optional)
     * @see #passwordHeader Wallet password. (optional)
     * return Object
     */
    public static class WalletRecoverOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v2/wallet/recover";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletRecoverOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v2/wallet/recover
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v2/wallet/recover
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ID_HEADER = "id";

        /**
         * @param id (String) Wallet id. (required)
         * @return operation
         */
        public WalletRecoverOper idHeader(String id) {
            reqSpec.addHeader(ID_HEADER, id);
            return this;
        }

        public static final String SEED_HEADER = "seed";

        /**
         * @param seed (String) Wallet seed. (required)
         * @return operation
         */
        public WalletRecoverOper seedHeader(String seed) {
            reqSpec.addHeader(SEED_HEADER, seed);
            return this;
        }

        public static final String SEED_PASSPHRASE_HEADER = "seed-passphrase";

        /**
         * @param seedPassphrase (String) Wallet seed-passphrase. (optional)
         * @return operation
         */
        public WalletRecoverOper seedPassphraseHeader(String seedPassphrase) {
            reqSpec.addHeader(SEED_PASSPHRASE_HEADER, seedPassphrase);
            return this;
        }

        public static final String PASSWORD_HEADER = "password";

        /**
         * @param password (String) Wallet password. (optional)
         * @return operation
         */
        public WalletRecoverOper passwordHeader(String password) {
            reqSpec.addHeader(PASSWORD_HEADER, password);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletRecoverOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletRecoverOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * This endpoint only works for encrypted wallets. If the wallet is unencrypted, The seed will be not returned.
     * 
     *
     * @see #idQuery Wallet Id. (required)
     * @see #passwordQuery Wallet password. (required)
     * return Object
     */
    public static class WalletSeedOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/wallet/seed";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletSeedOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/wallet/seed
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/wallet/seed
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ID_QUERY = "id";

        /**
         * @param id (String) Wallet Id. (required)
         * @return operation
         */
        public WalletSeedOper idQuery(Object... id) {
            reqSpec.addQueryParam(ID_QUERY, id);
            return this;
        }

        public static final String PASSWORD_QUERY = "password";

        /**
         * @param password (String) Wallet password. (required)
         * @return operation
         */
        public WalletSeedOper passwordQuery(Object... password) {
            reqSpec.addQueryParam(PASSWORD_QUERY, password);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletSeedOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletSeedOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Verifies a wallet seed.
     * 
     *
     * @see #seedHeader Seed to be verified. (optional)
     * return Object
     */
    public static class WalletSeedVerifyOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v2/wallet/seed/verify";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletSeedVerifyOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v2/wallet/seed/verify
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v2/wallet/seed/verify
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String SEED_HEADER = "seed";

        /**
         * @param seed (String) Seed to be verified. (optional)
         * @return operation
         */
        public WalletSeedVerifyOper seedHeader(String seed) {
            reqSpec.addHeader(SEED_HEADER, seed);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletSeedVerifyOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletSeedVerifyOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Creates a signed transaction
     * 
     *
     * @see #body  (required)
     * return Object
     */
    public static class WalletTransactionOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/wallet/transaction";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletTransactionOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType("application/json");
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/wallet/transaction
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/wallet/transaction
         * @param handler handler
         * @return Object
         */
        public Object executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<Object>(){}.getType();
            return execute(handler).as(type);
        }

         /**
         * @param walletTransactionRequest (WalletTransactionRequest)  (required)
         * @return operation
         */
        public WalletTransactionOper body(WalletTransactionRequest walletTransactionRequest) {
            reqSpec.setBody(walletTransactionRequest);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletTransactionOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletTransactionOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Creates a signed transaction
     * 
     *
     * @see #body  (required)
     * return InlineResponse2009
     */
    public static class WalletTransactionSignOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v2/wallet/transaction/sign";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletTransactionSignOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setContentType("application/json");
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v2/wallet/transaction/sign
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v2/wallet/transaction/sign
         * @param handler handler
         * @return InlineResponse2009
         */
        public InlineResponse2009 executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<InlineResponse2009>(){}.getType();
            return execute(handler).as(type);
        }

         /**
         * @param walletTransactionSignRequest (WalletTransactionSignRequest)  (required)
         * @return operation
         */
        public WalletTransactionSignOper body(WalletTransactionSignRequest walletTransactionSignRequest) {
            reqSpec.setBody(walletTransactionSignRequest);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletTransactionSignOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletTransactionSignOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * 
     *
     * @see #idQuery Wallet Id. (required)
     * return InlineResponse2006
     */
    public static class WalletTransactionsOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/wallet/transactions";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletTransactionsOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/wallet/transactions
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/wallet/transactions
         * @param handler handler
         * @return InlineResponse2006
         */
        public InlineResponse2006 executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<InlineResponse2006>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ID_QUERY = "id";

        /**
         * @param id (String) Wallet Id. (required)
         * @return operation
         */
        public WalletTransactionsOper idQuery(Object... id) {
            reqSpec.addQueryParam(ID_QUERY, id);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletTransactionsOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletTransactionsOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Unloads wallet from the wallet service.
     * 
     *
     * @see #idQuery Wallet Id. (required)
     */
    public static class WalletUnloadOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/wallet/unload";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletUnloadOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/wallet/unload
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        public static final String ID_QUERY = "id";

        /**
         * @param id (String) Wallet Id. (required)
         * @return operation
         */
        public WalletUnloadOper idQuery(Object... id) {
            reqSpec.addQueryParam(ID_QUERY, id);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletUnloadOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletUnloadOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * Update the wallet.
     * 
     *
     * @see #idHeader Wallet Id. (required)
     * @see #labelHeader The label the wallet will be updated to. (required)
     * return String
     */
    public static class WalletUpdateOper {

        public static final Method REQ_METHOD = POST;
        public static final String REQ_URI = "/api/v1/wallet/update";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletUpdateOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * POST /api/v1/wallet/update
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * POST /api/v1/wallet/update
         * @param handler handler
         * @return String
         */
        public String executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<String>(){}.getType();
            return execute(handler).as(type);
        }

        public static final String ID_HEADER = "id";

        /**
         * @param id (String) Wallet Id. (required)
         * @return operation
         */
        public WalletUpdateOper idHeader(String id) {
            reqSpec.addHeader(ID_HEADER, id);
            return this;
        }

        public static final String LABEL_HEADER = "label";

        /**
         * @param label (String) The label the wallet will be updated to. (required)
         * @return operation
         */
        public WalletUpdateOper labelHeader(String label) {
            reqSpec.addHeader(LABEL_HEADER, label);
            return this;
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletUpdateOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletUpdateOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
    /**
     * 
     * Returns all loaded wallets
     *
     * return List&lt;Object&gt;
     */
    public static class WalletsOper {

        public static final Method REQ_METHOD = GET;
        public static final String REQ_URI = "/api/v1/wallets";

        private RequestSpecBuilder reqSpec;
        private ResponseSpecBuilder respSpec;

        public WalletsOper(RequestSpecBuilder reqSpec) {
            this.reqSpec = reqSpec;
            reqSpec.setAccept("application/json");
            this.respSpec = new ResponseSpecBuilder();
        }

        /**
         * GET /api/v1/wallets
         * @param handler handler
         * @param <T> type
         * @return type
         */
        public <T> T execute(Function<Response, T> handler) {
            return handler.apply(RestAssured.given().spec(reqSpec.build()).expect().spec(respSpec.build()).when().request(REQ_METHOD, REQ_URI));
        }

        /**
         * GET /api/v1/wallets
         * @param handler handler
         * @return List&lt;Object&gt;
         */
        public List<Object> executeAs(Function<Response, Response> handler) {
            Type type = new TypeToken<List<Object>>(){}.getType();
            return execute(handler).as(type);
        }

        /**
         * Customise request specification
         * @param consumer consumer
         * @return operation
         */
        public WalletsOper reqSpec(Consumer<RequestSpecBuilder> consumer) {
            consumer.accept(reqSpec);
            return this;
        }

        /**
         * Customise response specification
         * @param consumer consumer
         * @return operation
         */
        public WalletsOper respSpec(Consumer<ResponseSpecBuilder> consumer) {
            consumer.accept(respSpec);
            return this;
        }
    }
}
